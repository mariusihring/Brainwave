schema {
	query: Query
	mutation: Mutation
}

type Appointment {
	courseId: UUID
	date: NaiveDate!
	endTime: NaiveDateTime!
	id: UUID!
	isCanceled: Boolean!
	location: String
	startTime: NaiveDateTime!
	title: String!
	userId: UUID!
}

type Course {
	academicDepartment: String
	grade: Float
	id: UUID!
	moduleId: UUID!
	name: String!
	teacher: String
	userId: UUID!
}

type Module {
	endSemester: UUID
	etCs: Int!
	grade: Float
	id: UUID!
	name: String!
	startSemester: UUID!
	userId: UUID!
}

type Mutation {
	createCourse(input: NewCourse!): Course!
	createModule(input: NewModule!): Module!
	createMultipleCourses(input: [String!]!): [Course!]!
	createSemester(input: NewSemester!): Semester!
	createTodo(input: NewTodo!): Todo!
	processSemesterCalendar(semesterId: String!): [RecurringAppointment!]!
	updateTodo(id: String!, input: UpdateTodo!): Todo!
	upsertCalendarLink(calendarLink: String): Settings!
}

"""
ISO 8601 calendar date without timezone.
Format: %Y-%m-%d

# Examples

* `1994-11-13`
* `2000-02-24`
"""
scalar NaiveDate

"""
ISO 8601 combined date and time without timezone.

# Examples

* `2015-07-01T08:59:60.123`,
"""
scalar NaiveDateTime

"""
ISO 8601 time without timezone.
Allows for the nanosecond precision and optional leap second representation.
Format: %H:%M:%S%.f

# Examples

* `08:59:60.123`
"""
scalar NaiveTime

input NewCourse {
	academicDepartment: String
	grade: Float
	name: String!
	teacher: String
}

input NewModule {
	ects: Int!
	endSemester: String
	grade: Float
	name: String!
	startSemester: String!
}

input NewSemester {
	endDate: NaiveDate!
	semester: Int!
	startDate: NaiveDate!
	totalEcts: Int!
}

input NewTodo {
	courseId: UUID
	dueOn: NaiveDateTime!
	notes: String
	title: String!
}

type Query {
	appointments: [Appointment!]!
	calendarLink: String
	course(id: String!): Course!
	courses: [Course!]!
	module(id: String!): Module
	modules: [Module!]!
	semester(semester: Int!): Semester
	semesters: [Semester!]!
	todo(id: String!): Todo
	todos: [Todo!]!
	todosByDate(date: NaiveDate!): [Todo!]!
}

type RecurringAppointment {
	endTime: NaiveTime!
	location: String!
	name: String!
	startTime: NaiveTime!
	weekday: WeekdayEnum!
}

type Semester {
	courses: [Course!]!
	endDate: NaiveDate!
	id: UUID!
	importedAppointments: Boolean!
	modules: [Module!]!
	semester: Int!
	semesterHash: String!
	startDate: NaiveDate!
	totalEcTs: Int!
	userId: UUID!
}

type Settings {
	calendarLink: String
	id: UUID!
	userId: UUID!
}

type Todo {
	courseId: UUID
	dueOn: NaiveDateTime!
	id: UUID!
	notes: String
	status: TodoStatus!
	title: String!
	type: TodoType!
	userId: UUID!
}

enum TodoStatus {
	COMPLETED
	INPROGRESS
	PENDING
}

enum TodoType {
	ASSIGNMENT
	EXAM
	GENERAL
}

"""
A UUID is a unique 128-bit number, stored as 16 octets. UUIDs are parsed as
Strings within GraphQL. UUIDs are used to assign unique identifiers to
entities without requiring a central allocating authority.

# References

* [Wikipedia: Universally Unique Identifier](http://en.wikipedia.org/wiki/Universally_unique_identifier)
* [RFC4122: A Universally Unique IDentifier (UUID) URN Namespace](http://tools.ietf.org/html/rfc4122)
"""
scalar UUID

input UpdateTodo {
	courseId: UUID
	dueOn: NaiveDateTime!
	id: UUID!
	notes: String
	title: String!
}

enum WeekdayEnum {
	FRIDAY
	MONDAY
	SATURDAY
	SUNDAY
	THURSDAY
	TUESDAY
	WEDNESDAY
}
